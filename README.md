# Hybrid-Chain Design Prototype
```css
Project/
â”‚
â””â”€â”€ Code/
â”‚   â”œâ”€â”€ MerkleTree.cpp
â”‚   â”œâ”€â”€ mempool.cpp
â”‚   â”œâ”€â”€ SNsample.sol /* snapshot demo in Solidity */
â”‚   â”œâ”€â”€ To be continued ......
â”‚   â””â”€â”€ build/
â”‚       â”œâ”€â”€ MerkleTree
â”‚       â”œâ”€â”€ ......
â”‚       â””â”€â”€inp.txt
â””â”€â”€ Content/
    â”œâ”€â”€ GeneralDesign.drawio
    â”œâ”€â”€ OverallStructure.drawio
    â”œâ”€â”€ PrivateChainExample.drawio
    â””â”€â”€ HybridChainExample.drawio
```
## Code
### Merkle Tree

C++ 17 and OpenSSL to implement a foundamental Merkle Tree.
#### Build Instructions:
Run the following commands in the directory containing ```CMakeLists.txt``` and ```MerkleTree.cpp```:
```bash
mkdir build
cd build
cmake ..
make
```
(I have done this stpe in the repo ËƒÊË‚ )

After the executable is generated:

``` bash
./MerkleTree
```

#### Input
During execution, the program reads:
```bash
inp.txt
```
from the current working directory.

Since running the executable inside the ```build/``` directory, ```inp.txt``` must be placed inside the build directory (I also did this in the repo âœŒï¸Ž( á› )âœŒï¸Ž).

Example directory structure:
```css
Code/
â”‚
â”œâ”€â”€ MerkleTree.cpp
â”œâ”€â”€ CMakeLists.txt
â”‚
â””â”€â”€ build/
    â”œâ”€â”€ MerkleTree    â† Executable
    â””â”€â”€ inp.txt       â† Input file must be here :)
```
##### Why?ðŸ¤”

Because what I did in the ```cpp``` file is:
```cpp
T.Build("inp.txt");
```
So you have no other choiceðŸ˜, unless you change it(but what do you want to doðŸ™€)

Therefore, the file must exist in the directory where the executable is run.

#### Menu
After launching, the following menu appears:
```
A)dd a new block
R)equest a block
V)erify the proof
T)raverse the tree
Q)uit
```
*A â€” Add a new block*

Appends the block content to the bottom of the tree and updates hashes from bottom to top.

*R â€” Request a block (Generate proof)*

Enter a block number to output its Merkle proof string.

*V â€” Verify the proof*

Uses the proof generated by the last R command to perform verification.

*T â€” Traverse the tree*

Prints all leaf block IDs and their corresponding SHA-256 hashes.

*Q - Quit*

Structure Overview

- Node

    - Stores blockID, data value, hashValue

    - Pointers: left / right / parent

- MerkleTree

    - Reads fixed-size blocks from a file

    - Uses OpenSSL to compute SHA-256

    - Builds a complete binary tree

    - Supports appending new blocks

    - Supports generating and verifying Merkle proofs

    - Supports printing leaf nodes

#### Potential Problems
Also list in the comment in the codeðŸ˜¢:(1~4 is acceptable 4 demo version)
```cpp
/*
1. Append() assumes the tree is a complete binary tree
It relies on every left/right child existing; 
it fails when the initial tree (built from input) is not complete, leading to null pointer access.

2. levels and blockNo are calculated incorrectly
The computed levels do not match the real tree height; 
path traversal during append becomes incorrect and leads to invalid pointer access.

3. Append algorithm is hard-coded and non-general
It works only for perfect binary trees; 
it breaks as soon as the tree structure deviates, such as with small or uneven input.

4. Proof format is non-standard
It mixes raw values and hashes; 
it is incompatible with proper Merkle proof formats used in real systems.

5. No boundary or safety checks (doneðŸ‘ŠðŸ”¥)
Null pointers, incomplete paths, empty input, and malformed proofs are never validated; 
errors lead directly to crashes.

6. Memory is never freed (This one has done Æª(Ë˜âŒ£Ë˜)Êƒ )
All nodes allocated with new are leaked; 
acceptable in a demo but a clear flaw in implementation.

*/
```

Optimization is on its way ðŸ§¯ (I hope so ðŸ˜†) *May generate a vector/array version hhhhh*
- â˜ï¸ðŸ¤“12.05: I found that the program is blocking on input, after entering A in the panel, not quite sure the problem, I may need to double check the logicðŸ˜­
- 12.07: 
Conclusion

|Bug|Causes|Fix|
|---|---|---|
|Crash on Append (SegFault)|The ```Append``` algorithm assumed a perfect tree and accessed ```nullptr``` (invalid memory) when the tree structure was uneven.|Added null pointer checks.
|Infinite Loop (System Freeze)|A logic error (```root->parent = parentN```) created a circular reference (cycle) in the tree, causing the traversal to loop forever.|Removed the incorrect pointer assignment.
|Input Spam (Menu Glitch)|Entering a character (like 'q') when an integer was expected caused ```cin``` to fail repeatedly without clearing the buffer.|Added ```cin.clear()``` and buffer flushing to handle invalid input.
|Verify Crash (```out_of_range```)| The ```Verify``` function attempted to slice (```substr```) an empty proof string before any block was requested.|Added a string length check.
|Always "Not Verified"|The ```Verify``` function hashed the input leaf value one extra time at the start, making it impossible to match the root.|Removed the redundant ```SHA256``` call.
|Result Loss|The variable storing the proof result was reset every time the menu loop refreshed.|Made the variable ```static``` so it remembers the data between menu actions.|


### Memory Pool
#### Why this one?
- Because this one is very important for miners in Blockchain.
- The mempool serves as the blockchainâ€™s staging area for unconfirmed transactions. All transactions broadcast to the network enter the mempool before they are written into a block, giving miners a real-time pool of candidates to choose from. It allows miners to prioritize transactions by fee, ensures the network maintains a consistent view of pending activity, and acts as the systemâ€™s transaction buffer and scheduler.

Working on now~~ ðŸ’ª
## Content